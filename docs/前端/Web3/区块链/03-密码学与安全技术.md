# 密码学与安全技术

## 一、Hash 算法

`Hash`（哈希或散列）算法，又常被称为指纹（`fingerprint`）或摘要（`digest`）算法。可以将任意长度的二进制明文串映射为较短的（通常是固定长度的）二进制串（Hash 值）。

**可以理解为一种单向有损压缩函数**。

```shell
# 举例计算一段字符串的 SHA-256 哈希值
echo -n "Hello, world!" | shasum -a 256

# 输出
# a591a6d40bf420404a011733cfb7b190d62c65bf0bcda2f7b097e2b6f3b6a205
```

哈希函数有很多种，不同的哈希函数有不同的设计目的、应用场景和特性。密码学中，采用的哈希函数名为加密哈希函数，因其有两个重要性质分别为**抗哈希碰撞**、**隐藏性*。


1. **抗哈希碰撞（Collision Resistance）**  

    给定 x 和 y，且有 x!=y，再给定一个哈希函数 `Hash()`，可以得到 `Hash(x) = Hash(y)`，则称为 **哈希碰撞。**

    之所以会存在哈希碰撞，是因为哈希函数 `Hash()` 的输出空间是有限的，而输入空间是无限的。 比如 256 位的哈希值，输出空间 2^256，输入空间无限，根据鸽笼原理，终究会有哈希碰撞。

    `Collision Resistance` 保证，如果有 `Hash(x) != Hash(y)`，必然可以得到 `x != y`。（当然，这是理想状态，实际应用中，哈希碰撞基本上难以避免。目前并不存在一个 hash 函数可以从数学上证明具有 Collision Resistance 的性质）

2. **隐藏性（Hiding）**  
    即无法从散列值逆向推导出原始数据。


::: warning 谜题友好性（Puzzle Friendly）
事实上，在比特币系统中，还需要第三个性质 Puzzle friendly。该性质要求哈希值计算事先不可预测，仅仅根据输入很难预测出输出。例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。

 - 计算上困难但验证简单：解决某个问题需要大量的计算资源或复杂的推理过程，但一旦解答出来，验证正确性应该是快速且简单的。
 - 随机性或不可预测性：谜题的解答无法通过简单的逻辑或预先推测得出，需要参与者进行尝试或使用某种搜索过程。这种不可预测性对防止作弊或预知答案至关重要。
 - 逐步逼近的解法：一些谜题友好的系统允许通过不断尝试或逐步逼近的方式最终找到解答。比如在比特币的 PoW 算法中，矿工通过不断变更 nonce 来找到符合要求的哈希值。
 - 抗作弊性：谜题友好性还可能包含对抗作弊的设计，确保谜题只能通过正当的计算和逻辑解答，而不是通过捷径或攻击手段快速破解。

:::

### 扩展：哈希函数类型
![alt text](https://raw.githubusercontent.com/whisper-xiang/image-hosting/master/whisper-vitepress-blog/哈希函数类型.png)

## 二、加解密算法
加解密算法分为对称加密算法和非对称加密算法。

### 2.1 对称加密算法

对称加密算法，加密和解密使用相同的密钥。

该类算法优点是加解密效率（速度快，空间占用小）和加密强度都很高。


### 2.2 非对称加密算法

非对称加密算法，加密和解密使用不同的密钥，分别称为公钥（Public Key）和私钥（Private Key）。

公钥和私钥是一对，分别由两个不同的密钥生成算法生成。公钥是公开的，他人可获取的；私钥则是个人持有并且要严密保护，不能被他人获取。

非对称加密算法优点是公私钥分开，无需安全通道来分发密钥。缺点是处理速度（特别是生成密钥和解密过程）往往比较慢，一般比对称加解密算法慢 2~3 个数量级；同时加密强度也往往不如对称加密。

1. 非对称性：
   公私钥加密是一种非对称加密方式，意味着加密和解密使用的是不同的密钥。公钥加密的信息只有配对的私钥可以解密，反之，私钥加密的信息可以用公钥解密。
2. 安全性：
   私钥是保密的，必须由持有者安全地存储，不能泄露给他人。公钥则可以公开发布，供其他人使用。即使攻击者获得了公钥，也无法解密通过公钥加密的消息，因为解密必须要有私钥。
3. 私钥可推导出公钥，公钥不可推导出私钥。

## 三、数字签名

在第三方中心化系统中，账户开通依赖于第三方。但去中心化的比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对。

比特币账户创立
  - 本地建立公私钥对（asymmetric encryption algorithm 非对称加密）。
  - 公钥相当于银行账号；私钥相当于银行卡密码；
  - 加密主要用于签名， **比特币交易需要用私钥签名，其他人用公钥验证。**
  - 在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。也就是说，只有拥有私钥，才能将该账户中的比特币转走。


## Merkle 树结构
默克尔树（又叫哈希树）是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。

其主要特点为：

- 最下面的叶节点包含存储数据或其哈希值；
- 非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。

进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。

默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。

### 结构
![Merkle 树结构](https://raw.githubusercontent.com/whisper-xiang/image-hosting/master/whisper-vitepress-blog/Merkle.png)

### 作用
 - 证明某个集合中存在或不存在某个元素
    通过构建集合的默克尔树，并提供该元素各级兄弟节点中的 Hash 值，可以不暴露集合完整内容而证明某元素存在。

  另外，对于可以进行排序的集合，可以将不存在元素的位置用空值代替，以此构建稀疏默克尔树（Sparse Merkle Tree）。该结构可以证明某个集合中不包括指定元素。
 - 快速比较大量数据
    对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。

    由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。
 - 快速定位修改
    以上图为例，基于数据 D0……D3 构造默克尔树，如果 D1 中数据被修改，会影响到 N1，N4 和 Root。

    因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root --> N4 --> N1，最多通过 O(lgN) 时间即可快速定位到实际发生改变的数据块 D1。
 - 零知识证明


 ## 双花攻击


 ## 51% 攻击

## 参考

- [北京大学肖臻老师《区块链技术与应用》](https://www.bilibili.com/video/av37065233/?p=2)
- [区块链技术指南](https://yeasy.gitbook.io/)
